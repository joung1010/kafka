## 프로듀서
카프카에서 **데이터의 시작점**은 프로듀서이다.  
  
애플리케이션은 카프카에 필요한 데이터를 선언하고 브로커의 특정 토픽의 파티션에 전송한다. 프로듀서는 데이터를 전송할 때 리더 파티션을 가지고 있는 카프카 브로커와 직접 통신한다.  
  
카프카 브로커로 데이터를 전손할 때 내부적으로 파티셔너, 배치 새성 단계를 거친다.

## 프로듀서 동작 흐름도

```

┌─────────────────────────────────────────────────────────────────────────┐
│                          프로듀서 애플리케이션                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────┐                                                       │
│  │   비즈니스   │  send(ProducerRecord)                                 │
│  │    로직     │ ──────────────────┐                                   │
│  └─────────────┘                   ▼                                   │
│                          ┌─────────────────────┐                       │
│                          │   ProducerRecord    │                       │
│                          │  ┌───────────────┐  │                       │
│                          │  │ Topic: orders │  │                       │
│                          │  │ Key: user123  │  │                       │
│                          │  │ Value: {...}  │  │                       │
│                          │  │ Headers: []   │  │                       │
│                          │  └───────────────┘  │                       │
│                          └──────────┬──────────┘                       │
│                                     ▼                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         Interceptors                             │   │
│  │                    (메시지 변환/모니터링)                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                     ▼                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         Serializer                               │   │
│  │  ┌─────────────────┐       ┌─────────────────┐                 │   │
│  │  │ Key Serializer  │       │ Value Serializer │                 │   │
│  │  │ String → byte[] │       │ JSON → byte[]    │                 │   │
│  │  └─────────────────┘       └─────────────────┘                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                     ▼                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         Partitioner                              │   │
│  │                                                                  │   │
│  │   Key가 있는 경우:  hash(key) % partition_count                 │   │
│  │   Key가 없는 경우:  Round-Robin or Sticky Partitioner           │   │
│  │                                                                  │   │
│  │   결정된 파티션: Partition 2                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                     ▼                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Record Accumulator                            │   │
│  │                    (레코드 누적기)                               │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │   │
│  │  │ Partition 0  │  │ Partition 1  │  │ Partition 2  │         │   │
│  │  │ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │         │   │
│  │  │ │  Batch 1 │ │  │ │  Batch 1 │ │  │ │  Batch 1 │ │ ◄─┐     │   │
│  │  │ │ [R1,R2]  │ │  │ │ [R5,R6]  │ │  │ │ [R3,R4]  │ │   │     │   │
│  │  │ └──────────┘ │  │ └──────────┘ │  │ └──────────┘ │   │     │   │
│  │  │ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │   │     │   │
│  │  │ │  Batch 2 │ │  │ │  Batch 2 │ │  │ │  Batch 2 │ │   │     │   │
│  │  │ │   [R7]   │ │  │ │    []    │ │  │ │ [R8,R9]  │ │   │     │   │
│  │  │ └──────────┘ │  │ └──────────┘ │  │ └──────────┘ │   │     │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │   │
│  │                                                                  │   │
│  │  설정값:                                                         │   │
│  │  - batch.size: 16KB (배치 최대 크기)                           │   │
│  │  - linger.ms: 10ms (배치 대기 시간)                            │   │
│  │  - buffer.memory: 32MB (전체 버퍼 크기)                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                     ▼                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      Sender Thread                               │   │
│  │                   (네트워크 I/O 스레드)                         │   │
│  │                                                                  │   │
│  │  1. 배치가 꽉 차거나 linger.ms 시간이 지나면 전송 준비         │   │
│  │  2. 브로커별로 요청을 그룹화                                   │   │
│  │  3. 압축 알고리즘 적용 (설정된 경우)                           │   │
│  │  4. 네트워크를 통해 브로커로 전송                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                            카프카 클러스터                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐        │
│  │   Broker 0      │  │   Broker 1      │  │   Broker 2      │        │
│  │                 │  │                 │  │                 │        │
│  │  ┌───────────┐  │  │  ┌───────────┐  │  │  ┌───────────┐  │        │
│  │  │Partition 0│  │  │  │Partition 1│  │  │  │Partition 2│  │        │
│  │  │ (Leader)  │  │  │  │ (Leader)  │  │  │  │ (Leader)  │  │ ◄──┐   │
│  │  └───────────┘  │  │  └───────────┘  │  │  └───────────┘  │    │   │
│  │  ┌───────────┐  │  │  ┌───────────┐  │  │  ┌───────────┐  │    │   │
│  │  │Partition 1│  │  │  │Partition 2│  │  │  │Partition 0│  │    │   │
│  │  │ (Follower)│  │  │  │ (Follower)│  │  │  │ (Follower)│  │    │   │
│  │  └───────────┘  │  │  └───────────┘  │  │  └───────────┘  │    │   │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘        │
│                                                                         │
│  프로듀서는 리더 파티션과만 직접 통신                                  │
└─────────────────────────────────────────────────────────────────────────┘

```
  
## 프로두서 내부 구조(자바 라이브러리 기준)

### 1. ProducerRecord

프로듀서가 전송하는 데이터의 기본 단위입니다.(오프셋 미포함)

오프셋은 이 레코드가 특정 파티션에 지정되어 저장되고 나서 지정된다.

- **Topic**: 메시지가 전송될 토픽
- **Partition**: (선택) 특정 파티션 지정
- **Key**: (선택) 파티셔닝에 사용되는 키
- **Value**: 실제 메시지 내용
- **Headers**: (선택) 메타데이터

### 2. Send

레코드 전송 요청 메서드

### 3. Partitioner

레코드를 어느 파티션으로 전송할지 결정합니다.

- **DefaultPartitioner**: 키가 있으면 해시 기반, 없으면 라운드 로빈
- **RoundRobinPartitioner**: 순차적으로 파티션 할당
- **UniformStickyPartitioner**: 배치 효율성을 위해 일정 시간 동안 같은 파티션 사용

### 4. Record Accumulator

배치로 묶어 전송할 데이터를 모으는 버

- 전송 전 레코드를 배치로 묶어 관리
- 파티션별로 배치 큐 유지
- 네트워크 효율성과 처리량 향상

### 5. Sender Thread

- 백그라운드에서 실행되는 I/O 스레드
- 배치를 실제로 브로커에 전송
- 재시도 로직 처리  

## 프로듀서- 기본 파티셔너
  
프로듀서 API를 사용하면 `UniformStickyPartitioner` 와 `RoundRobinPartitioner` 2개 파티셔너를 제공한다.  
  
카프카 클라이언트 라이브러리 2.5.0 버전에서 파티셔너를 지정하지 않은 경우 `UniformStickyPartitioner`가 피티셔너로 기본 설정된다.
  
메시지 키가 있을 경우 동작
 - `UniformStickyPartitioner` 와 `RoundRobinPartitioner` 둘다 메시지 키가 있을 때는 메시지 키의 해시값과 파티션을 매칭하여 레코드를 전송
 - 동일한 메시지 키가 존재하는 경우 레코드는 동일한 피티션 번호에 전달됨.
 - 만약 파티션 개수가 변경될 경우 메시지 키와 파티션 번호 매칭은 깨지게 됨 (변동시 기존 해시값이 변경되기 때문)
  
실 운영에서 메시지 키가 존재하는 토픽을 운영하는 경우 파티션의 개수를 조금 널널하게 잡고 운영하는 것이 변동을 최소한으로 줄일 수 있다.
  
**메시지 키가 없을때 동작**  
메시지 키가 없을 때는 파티션에 **최대한 동일하게 분배**하는 로직이 들어 있다.  
`UniformStickyPartitioner` 는 `RoundRobinPartitioner` 단점을 개선하였다는 점이 다르다.  

`RoundRobinPartitioner`  
- ProducerRecord가 들어오는 대로 파티션을 순회하면서 전송한다.
- 어큐뮤레이션에서 묶이는 정도가 적기 때문에 전송 성능이 낮음.  

`UniformStickyPartitioner`
- 어큐뮤레이터에서 레코드들이 배치로 묶일 때까지 기다렸다가 전송한다.
- 배치로 묶일 뿐 결국 파티션을 순회하면서 보내기 때문에 모든 파티션에 분배되어 전송한다.
- `RoundRobinPartitioner`에 비해 향상된 성능을 가진다.

## 커스텀 파티셔너
  
카프카 라이브러리에서는 사용자 지정 파티셔너를 생성하기 위한 `Partitioner`인터페이스를 제공한다. `Partitioner` 인터페이스를 상속받는 사용자 정의 클래스에서 메시지 키 또는 메시지 값에 따른 파티션 지정 로직을 적용할 수도 있다.  
  
파티셔너를 통해 파티션이 지정된 데이터는 어큐뮬레이터에 버퍼로 쌓인다. **센더** 스레드는 어큐뮬레이터에 쌓인 배치 데이터를 가져가 카프카 브로커로 전송한다.  

### 커스텀 파티셔너 구현

```java

import org.apache.kafka.clients.producer.Partitioner;
import org.apache.kafka.common.Cluster;
import java.util.Map;

public class CustomPartitioner implements Partitioner {

    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {

        int numPartitions = cluster.partitionCountForTopic(topic);

        if (key == null) {
// 키가 없으면 라운드 로빈
            return (int) (Math.random() * numPartitions);
        }

// VIP 고객은 특정 파티션으로
        if (key.toString().startsWith("VIP")) {
            return 0;// VIP 전용 파티션
        }

// 일반 고객은 해시 기반 분배
        return Math.abs(key.hashCode()) % numPartitions;
    }

    @Override
    public void close() {}

    @Override
    public void configure(Map<String, ?> configs) {}
}

```